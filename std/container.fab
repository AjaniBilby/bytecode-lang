import "memory.fab" as Memory;
import "vector.fab" as Memory;

/**
 * A static length array defined at compile time
 */
template <^Wild Type, Count>
class Container{
	public:
		Bytes<Count> data;

		void __constructor__(){
		}
		void __destructor__(){}

		/**
		 * Get the address of a specified element
		 * @param Specify which element by index number (starts from zero)
		 */
		@Type __get__(size_t index){
			if (index >= Count){
				throw "Index Error: Cannot get item "+index+" of "+Count;
			}

			@Type ptr = @this + (index * sizeof(Type));
			return ptr;
		}



		/**
		 * @return The number of elements this vector can hold without resizing
		 */
		size_t capacity(){
			return Count;
		}
		/**
		 * @return The length of the current vector
		 */
		size_t size(){
			return Count;
		}



		/**
		 * Get a sub section of this Container
		 * @param Which index to start the slice at
		 * @param Which index marks the end of the slice. (The slice will not include the element at this index)
		 * @returns The subsection of the container in vector form
		 */
		Vector<Type> slice(size_t start = 0, size_t end = 0){
			if (end == 0){
				end = Count-1;
			}else if (end >= Count){
				end = Count-1;
			}

			// Get the number of bytes and elements that will be moved
			size_t length = end - start;
			size_t bytes = length * sizeof(Type);

			Vector<Type> out;
			out.reserve(length);

			Memory::Duplicate(@this[0], @out[0], bytes);

			return out;
		};



		/**
		 * Set all elements in the container to the inputted value.
		 * Note this will not change elements that are reserved, but not within the active range.
		 * @param What value will all elements be set too?
		 */
		void fill(Type value){
			size_t length = this.size();
			for (size_t i=0; i<length; i++){
				this[i] = value;
			}
		}

		Vector<Type> __add__(^Container<Type> other){
			size_t len = other.size();
			Vector<Type> res(this);

			// Attach the new elements to the existing item
			res.concat(other);

			return res;
		}



		/**
		 * Find the index of a specific value
		 *   Can start the search at a specific offset
		 * @return a signed integer where -1 means the value was not found
		 */
		int64 indexOf(Type target, size_t startAt=0){
			size_t len = this.size();

			// Search through the container till the target value is found
			while (startAt < len){
				if (this[startAt] == target){
					return startAt;
				}

				startAt++;
			}

			return -1;
		}

		/**
		 * Find the index of a specific segment is found
		 *   Can start the search at a specific offset
		 * @return a signed integer where -1 means the value was not found
		 */
		int64 indexOf(^Container<Type> target, size_t startAt=0){
			size_t seg = target.size();
			size_t len = this.size() - seg;

			// Search through the container till the target segment is found
			while (startAt < len){
				bool match = true;
				for (size_t offset=0; offset<seg && match=true; offset++){
					if (this[startAt + offset] != target[offset]){
						match = false;
					}
				}

				if (match){
					return startAt;
				}

				startAt++;
			}

			return -1;
		}
}


expose Container;
