import "memory.fab" as Memory;
import "vector.fab" as Memory;

/**
 * A static length array defined at compile time
 */
Subject Container(Type, Count){
	public:
		Bytes<Count> data;

		void __constructor__(){
		}
		void __destructor__(){}

		/**
		 * Get the address of a specified element
		 * @param Specify which element by index number (starts from zero)
		 */
		@Type __get__(size_t index){
			if (index >= Count){
				throw "Index Error: Cannot get item "+index+" of "+Count;
			}

			@Type ptr = @this + (index * sizeof(Type));
			return ptr;
		}



		/**
		 * @return The number of elements this vector can hold without resizing
		 */
		size_t capacity(){
			return Count;
		}
		/**
		 * @return The length of the current vector
		 */
		size_t size(){
			return Count;
		}



		/**
		 * Get a sub section of this Container
		 * @param Which index to start the slice at
		 * @param Which index marks the end of the slice. (The slice will not include the element at this index)
		 * @returns The subsection of the container in vector form
		 */
		Vector<Type> slice(size_t start = 0, size_t end = 0){
			if (end == 0){
				end = Count-1;
			}else if (end >= Count){
				end = Count-1;
			}

			// Get the number of bytes and elements that will be moved
			size_t length = end - start;
			size_t bytes = length * sizeof(Type);

			Vector<Type> out;
			out.reserve(length);

			Memory::Duplicate(@this[0], @out[0], bytes);

			return out;
		};



		/**
		 * Set all elements in the container to the inputted value.
		 * Note this will not change elements that are reserved, but not within the active range.
		 * @param What value will all elements be set too?
		 */
		void fill(Type value){
			size_t length = this.size();
			for (size_t i=0; i<length; i++){
				this[i] = value;
			}
		}
}


expose Container;
