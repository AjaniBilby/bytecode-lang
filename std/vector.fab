import "container.fab" as Memory;
import "memory.fab" as Memory;

/**
 * A variable length array
 */
subject Vector(Type) extends Container<Type, 0>{
	private:
		size_t length;
		size_t heap;

		@Type reference;

	public:
		void __construct__(){
			this.length = 0;
			this.heap = 0;
			this.reference = nullptr;

			return;
		}
		void __destruct__(){
			Memory::Free(this.reference);

			return;
		}


		/**
		 * Makes a mirror of this vector ensuring that the elements of the new and old vector are independant
		 * @param The address to place the duplicate
		 */
		void __duplicate__(@Vector<Type> to){
			// Reserve the required space
			to.reserve( this.capacity() );
			to.resize ( this.size()     );

			// Duplicate elements individually
			//  Cater for element class behaviour
			size_t i=0;
			while (i < this.size){
				to[i] = this[i];
			}

			return;
		}

		/**
		 * Get the address of a specified element
		 * @param Specify which element by index number (starts from zero)
		 */
		@Type __get__(size_t index){
			// Check that the index is valid
			if (index >= this.size){
				throw "Index error: cannot get element " + index.toString() + " of " + this.size.toString();
			}

			return this.reference + (index * sizeof(Type));
		}

		/**
		 * Pushes the value to the vector
		 */
		Vector<Type> __add__(Type value){
			Vector<Type> res = this;
			res.push(value);

			return res;
		}
		/**
		 * Pushes the other vector to the end of this one
		 */
		Vector<Type> __add__(Vector<Type> value){
			Vector<Type> res = this;
			res.concat(value);

			return res;
		}



		/**
		 * @return The number of elements this vector can hold without resizing
		 */
		size_t capacity(){
			return this.heap;
		}
		/**
		 * @return The length of the current vector
		 */
		size_t size(){
			return this.length;
		}



		/**
		 * Increases the size of the container being used by the vector
		 * @param The number of elements the vector should now be able to hold
		 */
		void reserve(size_t items){
			@Type to = Memory.Allocate(items * sizeof(Type));

			size_t min = items;
			size_t length = this.capacity();
			if (length < min){
				min = length;
			}

			Memory::Duplicate(@this.reference, @to, min);
			return;
		}

		/**
		 * Changes the length of the vector to meet the specified length.
		 * This may trigger a reserve if the vector needs to expand out side it's capacity
		 * @param The number of items the vector should now hold.
		 */
		void resize(size_t items){
			if (items > this.capacity()){
				this.reserve(items);
			}

			this.length = items;
			return;
		}



		/**
		 * Puts the desired element after the currect last item.
		 * @param The item to be added.
		 */
		void push(Type value){
			// Resize the vector to fit the new elements
			size_t i = this.length;
			this.resize(i+1);

			// Write the value
			this[i] = value;
			return;
		}
		/**
		 * Puts multiple items after the current last item.
		 * @param The elements to be added.
		 */
		void concat(@Vector<Type> value){
			size_t length = this.size();

			// Resize the vector to fit the new elements
			size_t offset = length;
			this.resize(length + value.size);

			// Duplicate each element
			//   Not bytewise to cater for class behaviour
			size_t i = 0;
			size_t size = value.size;
			while (size > 0){
				this[i + offset] = value[i];

				i = i + 1;
				size = size - 1;
			}
		}



		/**
		 * Get a sub section of this Container
		 * @param Which index to start the slice at
		 * @param Which index marks the end of the slice. (The slice will not include the element at this index)
		 * @returns The subsection of the container in vector form
		 */
		Vector<type> slice(size_t start = 0, size_t end = -1){
			// Check the inputs are valid
			if (end <= start){
				throw "Cannot create a slice with starting index \""+start+"\" and end index \""+end+"\"";
			}

			// Correct the ending point
			if (end > this.size){
				end = this.size;
			}

			// Create space for a result class
			size_t size = end - start;
			Vector<type> out(size);

			// Duplicate the elements
			//  Element based to account for class behaviour
			size_t i=0;
			while (start < end){
				out[i] = this[start];

				i += 1;
				start += 1;
			}

			return out;
		}

		/**
		 * Remove X elements from this vector shifting later elements back.
		 * Also return a vector of the elements removed
		 * @returns The elements removed
		 */
		Vector<type> splice(size_t start = 0, size_t elements = 1){
			Vector<type> out;
			size_t length = this.size();

			// You can only splice 0 elements out side of the vector
			if (start >= length){
				out.resize(0);
				return out;
			}

			// Ensure the splice does not go out of the array
			// If it does change the number of elements to fit within the array
			if (start + elements > length){
				elements = length - start;
			}

			// Inputs are correct
			out.reserve(elements);

			size_t shift = elements;
			size_t i=0;
			while (elements > 0){
				// Push the element to the splice result
				out.push(this[start]);

				// Shift the later elements back
				// If there are elements to be shifted
				if (shift+i < length){
					this[shift+i] = this[start];
				}

				elements = elements - 1;
				i = i + 1;
			}

			// Resize the vector now that elements have been removed
			this.resize(length - elements);

			return out;
		}
}

expose Vector;
