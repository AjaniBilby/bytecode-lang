import "memory.fab" as Memory;

class wild primative void {
	void __constructor__(){}
	void __destructor__(){}
	void __duplicate__(@wild other){
		Memory::Duplicate(@this, @other, sizeof(this));
	}

	/**
	 * Returns a heap description of this object
	 */
	Memory.Heap getHeap(){
		Memory.Heap out(@this, sizeof(this));
		return out;
	}
}
class void primative void {}


class bool primative bool {}


class Number primative double                {}

class int    primative int    extends number {}
class uint   primative        extends int    {}

class u8  primative uint      extends uint   {}
class u16 primative uint8     extends u8     {}
class u32 primative uint16    extends u32    {}
class u64 primative uint32    extends u64    {}

class size_t primative size_t extends uint   {}

class i8   primative int      extends uint   {}
class i16  primative int8     extends i8     {}
class i32  primative int16    extends i16    {}
class i64  primative int32    extends i32    {}

class float  primative float  extends number {}
class double primative double extends float  {}



expose wild; expose void;
expose bool;
expose number;
expose int; expose uint;
expose u8; expose u16; expose u32; expose u64;
expose size_t;
expose i8; expose i16; expose i32; expose i64;
expose float; expose double;




/**
 * Returns the size of a given class
 * @param the object or type who's size is in question.
 * @returns the number of bytes
 */
size_t sizeof(^wild target) primative sizeof;
expose sizeof;




/**
 * Reinterpete one class as another
 * Duplicate the bytewise information from one class to another
 */
template <^wild To>
To Reinterpret(^wild value){
	// Get the width of data to be moved
	size_t size = sizeof(this);
	if (sizeof(other) < size){
		size = sizeof(other);
	}

	// Copy the data at a bytewise level
	To out;
	Memory.Duplicate(@out, @this, size);

	return out;
}
expose Reinterpret;
